
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gorm-duckdb-driver: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/greysquirr3l/gorm-duckdb-driver/array_minimal.go (0.0%)</option>
				
				<option value="file1">github.com/greysquirr3l/gorm-duckdb-driver/array_support.go (0.0%)</option>
				
				<option value="file2">github.com/greysquirr3l/gorm-duckdb-driver/duckdb.go (42.2%)</option>
				
				<option value="file3">github.com/greysquirr3l/gorm-duckdb-driver/error_translator.go (0.0%)</option>
				
				<option value="file4">github.com/greysquirr3l/gorm-duckdb-driver/extensions.go (0.0%)</option>
				
				<option value="file5">github.com/greysquirr3l/gorm-duckdb-driver/migrator.go (21.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package duckdb provides a GORM driver for DuckDB database.
// This file contains minimal array support for basic DuckDB array operations.
package duckdb

import (
        "database/sql/driver"
        "fmt"
        "reflect"
        "strings"
)

// formatSliceForDuckDB converts a Go slice to DuckDB array literal syntax
func formatSliceForDuckDB(value interface{}) (string, error) <span class="cov0" title="0">{
        v := reflect.ValueOf(value)
        if v.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return "", fmt.Errorf("expected slice, got %T", value)
        }</span>

        <span class="cov0" title="0">if v.Len() == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>

        <span class="cov0" title="0">var elements []string
        for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                elem := v.Index(i)
                switch elem.Kind() </span>{
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        elements = append(elements, fmt.Sprintf("%g", elem.Float()))</span>
                case reflect.String:<span class="cov0" title="0">
                        // Escape single quotes in strings
                        str := strings.ReplaceAll(elem.String(), "'", "''")
                        elements = append(elements, fmt.Sprintf("'%s'", str))</span>
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        elements = append(elements, fmt.Sprintf("%d", elem.Int()))</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        elements = append(elements, fmt.Sprintf("%d", elem.Uint()))</span>
                case reflect.Bool:<span class="cov0" title="0">
                        if elem.Bool() </span><span class="cov0" title="0">{
                                elements = append(elements, "true")
                        }</span> else<span class="cov0" title="0"> {
                                elements = append(elements, "false")
                        }</span>
                default:<span class="cov0" title="0">
                        return "", fmt.Errorf("unsupported slice element type: %v", elem.Kind())</span>
                }
        }

        <span class="cov0" title="0">return "[" + strings.Join(elements, ", ") + "]", nil</span>
}

// ArrayLiteral wraps a Go slice to be formatted as a DuckDB array literal
type ArrayLiteral struct {
        Data interface{}
}

// Value implements driver.Valuer for DuckDB array literals
func (al ArrayLiteral) Value() (driver.Value, error) <span class="cov0" title="0">{
        if al.Data == nil </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>

        <span class="cov0" title="0">return formatSliceForDuckDB(al.Data)</span>
}

// SimpleArrayScanner provides basic array scanning functionality
type SimpleArrayScanner struct {
        Target interface{} // Pointer to slice
}

// Scan implements sql.Scanner for basic array types
//
//nolint:gocyclo // Complex parsing logic is acceptable for array utility
func (sas *SimpleArrayScanner) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Handle Go slice types directly (DuckDB returns []interface{})
        <span class="cov0" title="0">if slice, ok := value.([]interface{}); ok </span><span class="cov0" title="0">{
                targetValue := reflect.ValueOf(sas.Target)
                if targetValue.Kind() != reflect.Ptr || targetValue.Elem().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                        return fmt.Errorf("target must be pointer to slice")
                }</span>

                <span class="cov0" title="0">sliceType := targetValue.Elem().Type()
                elemType := sliceType.Elem()
                result := reflect.MakeSlice(sliceType, len(slice), len(slice))

                for i, elem := range slice </span><span class="cov0" title="0">{
                        elemValue := result.Index(i)

                        switch elemType.Kind() </span>{
                        case reflect.Float64:<span class="cov0" title="0">
                                // Handle both float32 and float64 from DuckDB
                                switch f := elem.(type) </span>{
                                case float64:<span class="cov0" title="0">
                                        elemValue.SetFloat(f)</span>
                                case float32:<span class="cov0" title="0">
                                        elemValue.SetFloat(float64(f))</span>
                                default:<span class="cov0" title="0">
                                        return fmt.Errorf("expected float32/float64, got %T at index %d", elem, i)</span>
                                }
                        case reflect.String:<span class="cov0" title="0">
                                if s, ok := elem.(string); ok </span><span class="cov0" title="0">{
                                        elemValue.SetString(s)
                                }</span> else<span class="cov0" title="0"> {
                                        return fmt.Errorf("expected string, got %T at index %d", elem, i)
                                }</span>
                        case reflect.Int64:<span class="cov0" title="0">
                                // Handle various integer types from DuckDB
                                switch i := elem.(type) </span>{
                                case int64:<span class="cov0" title="0">
                                        elemValue.SetInt(i)</span>
                                case int32:<span class="cov0" title="0">
                                        elemValue.SetInt(int64(i))</span>
                                case int:<span class="cov0" title="0">
                                        elemValue.SetInt(int64(i))</span>
                                default:<span class="cov0" title="0">
                                        return fmt.Errorf("expected integer type, got %T at index %d", elem, i)</span>
                                }
                        case reflect.Bool:<span class="cov0" title="0">
                                if b, ok := elem.(bool); ok </span><span class="cov0" title="0">{
                                        elemValue.SetBool(b)
                                }</span> else<span class="cov0" title="0"> {
                                        return fmt.Errorf("expected bool, got %T at index %d", elem, i)
                                }</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("unsupported target element type: %v", elemType.Kind())</span>
                        }
                }

                <span class="cov0" title="0">targetValue.Elem().Set(result)
                return nil</span>
        }

        // Fallback: Handle string representations of arrays
        <span class="cov0" title="0">var arrayStr string
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                arrayStr = v</span>
        case []byte:<span class="cov0" title="0">
                arrayStr = string(v)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("cannot scan %T into SimpleArrayScanner", value)</span>
        }

        // Parse DuckDB array format: [1.0, 2.0, 3.0] or [item1, item2, item3]
        <span class="cov0" title="0">arrayStr = strings.TrimSpace(arrayStr)
        if !strings.HasPrefix(arrayStr, "[") || !strings.HasSuffix(arrayStr, "]") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid array format: %s", arrayStr)
        }</span>

        // Remove brackets
        <span class="cov0" title="0">content := arrayStr[1 : len(arrayStr)-1]
        content = strings.TrimSpace(content)

        if content == "" </span><span class="cov0" title="0">{
                // Empty array
                targetValue := reflect.ValueOf(sas.Target)
                if targetValue.Kind() != reflect.Ptr || targetValue.Elem().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                        return fmt.Errorf("target must be pointer to slice")
                }</span>
                <span class="cov0" title="0">targetValue.Elem().Set(reflect.MakeSlice(targetValue.Elem().Type(), 0, 0))
                return nil</span>
        }

        // Split elements and parse based on target type
        <span class="cov0" title="0">elements := strings.Split(content, ",")
        targetValue := reflect.ValueOf(sas.Target)
        if targetValue.Kind() != reflect.Ptr || targetValue.Elem().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return fmt.Errorf("target must be pointer to slice")
        }</span>

        <span class="cov0" title="0">sliceType := targetValue.Elem().Type()
        elemType := sliceType.Elem()
        result := reflect.MakeSlice(sliceType, len(elements), len(elements))

        for i, elemStr := range elements </span><span class="cov0" title="0">{
                elemStr = strings.TrimSpace(elemStr)
                elemValue := result.Index(i)

                switch elemType.Kind() </span>{
                case reflect.Float64:<span class="cov0" title="0">
                        var f float64
                        if _, err := fmt.Sscanf(elemStr, "%f", &amp;f); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse float: %s", elemStr)
                        }</span>
                        <span class="cov0" title="0">elemValue.SetFloat(f)</span>
                case reflect.String:<span class="cov0" title="0">
                        // Remove quotes if present
                        if strings.HasPrefix(elemStr, "'") &amp;&amp; strings.HasSuffix(elemStr, "'") </span><span class="cov0" title="0">{
                                elemStr = elemStr[1 : len(elemStr)-1]
                                elemStr = strings.ReplaceAll(elemStr, "''", "'") // Unescape quotes
                        }</span>
                        <span class="cov0" title="0">elemValue.SetString(elemStr)</span>
                case reflect.Int64:<span class="cov0" title="0">
                        var i int64
                        if _, err := fmt.Sscanf(elemStr, "%d", &amp;i); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse int: %s", elemStr)
                        }</span>
                        <span class="cov0" title="0">elemValue.SetInt(i)</span>
                case reflect.Bool:<span class="cov0" title="0">
                        var b bool
                        if _, err := fmt.Sscanf(elemStr, "%t", &amp;b); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse bool: %s", elemStr)
                        }</span>
                        <span class="cov0" title="0">elemValue.SetBool(b)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported target element type: %v", elemType.Kind())</span>
                }
        }

        <span class="cov0" title="0">targetValue.Elem().Set(result)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package duckdb

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "strings"
)

// Helper function to parse array string representation
func parseArrayString(s string) []string <span class="cov0" title="0">{
        s = strings.TrimSpace(s)

        // Handle empty array
        if s == "[]" || s == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        // Remove brackets
        <span class="cov0" title="0">if strings.HasPrefix(s, "[") &amp;&amp; strings.HasSuffix(s, "]") </span><span class="cov0" title="0">{
                s = s[1 : len(s)-1]
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(s) == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov0" title="0">parts := strings.Split(s, ",")
        result := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov0" title="0">{
                result = append(result, strings.TrimSpace(part))
        }</span>

        <span class="cov0" title="0">return result</span>
}

// StringArray represents a DuckDB TEXT[] array type
type StringArray []string

// Value implements driver.Valuer interface for StringArray
func (a StringArray) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>

        <span class="cov0" title="0">if len(a) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>

        <span class="cov0" title="0">elements := make([]string, 0, len(a))
        for _, s := range a </span><span class="cov0" title="0">{
                // Escape single quotes in strings
                escaped := strings.ReplaceAll(s, "'", "''")
                elements = append(elements, fmt.Sprintf("'%s'", escaped))
        }</span>

        <span class="cov0" title="0">return "[" + strings.Join(elements, ", ") + "]", nil</span>
}

// Scan implements sql.Scanner interface for StringArray
func (a *StringArray) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *a = nil
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return a.scanFromString(v)</span>
        case []byte:<span class="cov0" title="0">
                return a.scanFromString(string(v))</span>
        case []interface{}:<span class="cov0" title="0">
                return a.scanFromSlice(v)</span>
        default:<span class="cov0" title="0">
                // Try JSON unmarshaling as fallback
                data, err := json.Marshal(value)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot scan %T into StringArray", value)
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(data, a); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal JSON data into StringArray: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func (a *StringArray) scanFromString(s string) error <span class="cov0" title="0">{
        s = strings.TrimSpace(s)

        // Handle empty array
        if s == "[]" || s == "" </span><span class="cov0" title="0">{
                *a = StringArray{}
                return nil
        }</span>

        // Remove brackets
        <span class="cov0" title="0">if strings.HasPrefix(s, "[") &amp;&amp; strings.HasSuffix(s, "]") </span><span class="cov0" title="0">{
                s = s[1 : len(s)-1]
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(s) == "" </span><span class="cov0" title="0">{
                *a = StringArray{}
                return nil
        }</span>

        // Simple CSV parsing - this could be enhanced for complex cases
        <span class="cov0" title="0">parts := strings.Split(s, ",")
        result := make(StringArray, 0, len(parts))

        for _, part := range parts </span><span class="cov0" title="0">{
                part = strings.TrimSpace(part)
                // Remove quotes if present
                if strings.HasPrefix(part, "'") &amp;&amp; strings.HasSuffix(part, "'") </span><span class="cov0" title="0">{
                        part = part[1 : len(part)-1]
                        // Unescape single quotes
                        part = strings.ReplaceAll(part, "''", "'")
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(part, "\"") &amp;&amp; strings.HasSuffix(part, "\"") </span><span class="cov0" title="0">{
                        part = part[1 : len(part)-1]
                        // Unescape double quotes
                        part = strings.ReplaceAll(part, "\"\"", "\"")
                }</span>
                <span class="cov0" title="0">result = append(result, part)</span>
        }

        <span class="cov0" title="0">*a = result
        return nil</span>
}

func (a *StringArray) scanFromSlice(slice []interface{}) error <span class="cov0" title="0">{
        result := make(StringArray, 0, len(slice))
        for _, item := range slice </span><span class="cov0" title="0">{
                result = append(result, fmt.Sprintf("%v", item))
        }</span>
        <span class="cov0" title="0">*a = result
        return nil</span>
}

// IntArray represents a DuckDB INTEGER[] array type
type IntArray []int64

// Value implements driver.Valuer interface for IntArray
func (a IntArray) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>

        <span class="cov0" title="0">if len(a) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>

        <span class="cov0" title="0">elements := make([]string, 0, len(a))
        for _, i := range a </span><span class="cov0" title="0">{
                elements = append(elements, fmt.Sprintf("%d", i))
        }</span>

        <span class="cov0" title="0">return "[" + strings.Join(elements, ", ") + "]", nil</span>
}

// Scan implements sql.Scanner interface for IntArray
func (a *IntArray) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *a = nil
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return a.scanFromString(v)</span>
        case []byte:<span class="cov0" title="0">
                return a.scanFromString(string(v))</span>
        case []interface{}:<span class="cov0" title="0">
                return a.scanFromSlice(v)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("cannot scan %T into IntArray", value)</span>
        }
}

func (a *IntArray) scanFromString(s string) error <span class="cov0" title="0">{
        parts := parseArrayString(s)

        if len(parts) == 0 </span><span class="cov0" title="0">{
                *a = IntArray{}
                return nil
        }</span>

        <span class="cov0" title="0">result := make(IntArray, 0, len(parts))
        for _, part := range parts </span><span class="cov0" title="0">{
                var i int64
                if _, err := fmt.Sscanf(part, "%d", &amp;i); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot parse '%s' as integer: %w", part, err)
                }</span>
                <span class="cov0" title="0">result = append(result, i)</span>
        }

        <span class="cov0" title="0">*a = result
        return nil</span>
}

func (a *IntArray) scanFromSlice(slice []interface{}) error <span class="cov0" title="0">{
        result := make(IntArray, 0, len(slice))
        for _, item := range slice </span><span class="cov0" title="0">{
                switch v := item.(type) </span>{
                case int64:<span class="cov0" title="0">
                        result = append(result, v)</span>
                case int:<span class="cov0" title="0">
                        result = append(result, int64(v))</span>
                case float64:<span class="cov0" title="0">
                        result = append(result, int64(v))</span>
                default:<span class="cov0" title="0">
                        var i int64
                        if _, err := fmt.Sscanf(fmt.Sprintf("%v", item), "%d", &amp;i); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot convert %T to int64: %w", item, err)
                        }</span>
                        <span class="cov0" title="0">result = append(result, i)</span>
                }
        }
        <span class="cov0" title="0">*a = result
        return nil</span>
}

// FloatArray represents a DuckDB DOUBLE[] array type
type FloatArray []float64

// Value implements driver.Valuer interface for FloatArray
func (a FloatArray) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>

        <span class="cov0" title="0">if len(a) == 0 </span><span class="cov0" title="0">{
                return "[]", nil
        }</span>

        <span class="cov0" title="0">elements := make([]string, 0, len(a))
        for _, f := range a </span><span class="cov0" title="0">{
                elements = append(elements, fmt.Sprintf("%g", f))
        }</span>

        <span class="cov0" title="0">return "[" + strings.Join(elements, ", ") + "]", nil</span>
}

// Scan implements sql.Scanner interface for FloatArray
func (a *FloatArray) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *a = nil
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return a.scanFromString(v)</span>
        case []byte:<span class="cov0" title="0">
                return a.scanFromString(string(v))</span>
        case []interface{}:<span class="cov0" title="0">
                return a.scanFromSlice(v)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("cannot scan %T into FloatArray", value)</span>
        }
}

func (a *FloatArray) scanFromString(s string) error <span class="cov0" title="0">{
        parts := parseArrayString(s)

        if len(parts) == 0 </span><span class="cov0" title="0">{
                *a = FloatArray{}
                return nil
        }</span>

        <span class="cov0" title="0">result := make(FloatArray, 0, len(parts))
        for _, part := range parts </span><span class="cov0" title="0">{
                var f float64
                if _, err := fmt.Sscanf(part, "%g", &amp;f); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot parse '%s' as float: %w", part, err)
                }</span>
                <span class="cov0" title="0">result = append(result, f)</span>
        }

        <span class="cov0" title="0">*a = result
        return nil</span>
}

func (a *FloatArray) scanFromSlice(slice []interface{}) error <span class="cov0" title="0">{
        result := make(FloatArray, 0, len(slice))
        for _, item := range slice </span><span class="cov0" title="0">{
                switch v := item.(type) </span>{
                case float64:<span class="cov0" title="0">
                        result = append(result, v)</span>
                case float32:<span class="cov0" title="0">
                        result = append(result, float64(v))</span>
                case int64:<span class="cov0" title="0">
                        result = append(result, float64(v))</span>
                case int:<span class="cov0" title="0">
                        result = append(result, float64(v))</span>
                default:<span class="cov0" title="0">
                        var f float64
                        if _, err := fmt.Sscanf(fmt.Sprintf("%v", item), "%g", &amp;f); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot convert %T to float64: %w", item, err)
                        }</span>
                        <span class="cov0" title="0">result = append(result, f)</span>
                }
        }
        <span class="cov0" title="0">*a = result
        return nil</span>
}

// GormDataType implements the GormDataTypeInterface for StringArray
func (StringArray) GormDataType() string <span class="cov0" title="0">{
        return "TEXT[]"
}</span>

// GormDataType implements the GormDataTypeInterface for IntArray
func (IntArray) GormDataType() string <span class="cov0" title="0">{
        return "BIGINT[]"
}</span>

// GormDataType implements the GormDataTypeInterface for FloatArray
func (FloatArray) GormDataType() string <span class="cov0" title="0">{
        return "DOUBLE[]"
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package duckdb

import (
        "context"
        "database/sql"
        "database/sql/driver"
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/marcboeker/go-duckdb/v2"
        "gorm.io/gorm"
        "gorm.io/gorm/callbacks"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/logger"
        "gorm.io/gorm/migrator"
        "gorm.io/gorm/schema"
)

// Dialector implements gorm.Dialector interface for DuckDB database.
type Dialector struct {
        *Config
}

// Config holds configuration options for the DuckDB dialector.
type Config struct {
        DriverName        string
        DSN               string
        Conn              gorm.ConnPool
        DefaultStringSize uint
}

// Open creates a new DuckDB dialector with the given DSN.
func Open(dsn string) gorm.Dialector <span class="cov8" title="1">{
        return &amp;Dialector{Config: &amp;Config{DSN: dsn}} // Remove DriverName to use default custom driver
}</span>

// New creates a new DuckDB dialector with the given configuration.
func New(config Config) gorm.Dialector <span class="cov0" title="0">{
        return &amp;Dialector{Config: &amp;config}
}</span>

// Name returns the name of the dialector.
func (dialector Dialector) Name() string <span class="cov8" title="1">{
        return "duckdb"
}</span>

func init() <span class="cov8" title="1">{
        sql.Register("duckdb-gorm", &amp;convertingDriver{&amp;duckdb.Driver{}})
}</span>

// Custom driver that converts time pointers at the lowest level
type convertingDriver struct {
        driver.Driver
}

func (d *convertingDriver) Open(name string) (driver.Conn, error) <span class="cov8" title="1">{
        conn, err := d.Driver.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database connection: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;convertingConn{conn}, nil</span>
}

type convertingConn struct {
        driver.Conn
}

func (c *convertingConn) Prepare(query string) (driver.Stmt, error) <span class="cov0" title="0">{
        stmt, err := c.Conn.Prepare(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;convertingStmt{stmt}, nil</span>
}

func (c *convertingConn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) <span class="cov0" title="0">{
        if prepCtx, ok := c.Conn.(driver.ConnPrepareContext); ok </span><span class="cov0" title="0">{
                stmt, err := prepCtx.PrepareContext(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to prepare statement with context: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;convertingStmt{stmt}, nil</span>
        }
        <span class="cov0" title="0">return c.Prepare(query)</span>
}

func (c *convertingConn) Exec(query string, args []driver.Value) (driver.Result, error) <span class="cov0" title="0">{
        // Convert to context-aware version - this is the recommended approach
        namedArgs := make([]driver.NamedValue, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                namedArgs[i] = driver.NamedValue{
                        Ordinal: i + 1,
                        Value:   arg,
                }
        }</span>
        <span class="cov0" title="0">return c.ExecContext(context.Background(), query, namedArgs)</span>
}

func (c *convertingConn) ExecContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) <span class="cov8" title="1">{
        if execCtx, ok := c.Conn.(driver.ExecerContext); ok </span><span class="cov8" title="1">{
                convertedArgs := convertNamedValues(args)
                result, err := execCtx.ExecContext(ctx, query, convertedArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute query with context: %w", err)
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }
        // Fallback to non-context version
        <span class="cov0" title="0">namedArgs := make([]driver.NamedValue, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                namedArgs[i] = driver.NamedValue{
                        Ordinal: i + 1,
                        Value:   arg.Value,
                }
        }</span>
        //nolint:contextcheck // Using Background context for fallback when no context is available
        <span class="cov0" title="0">return c.ExecContext(context.Background(), query, namedArgs)</span>
}

func (c *convertingConn) Query(query string, args []driver.Value) (driver.Rows, error) <span class="cov0" title="0">{
        // Convert to context-aware version - this is the recommended approach
        namedArgs := make([]driver.NamedValue, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                namedArgs[i] = driver.NamedValue{
                        Ordinal: i + 1,
                        Value:   arg,
                }
        }</span>
        <span class="cov0" title="0">return c.QueryContext(context.Background(), query, namedArgs)</span>
}

func (c *convertingConn) QueryContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) <span class="cov8" title="1">{
        if queryCtx, ok := c.Conn.(driver.QueryerContext); ok </span><span class="cov8" title="1">{
                convertedArgs := convertNamedValues(args)
                rows, err := queryCtx.QueryContext(ctx, query, convertedArgs)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to execute query with context: %w", err)
                }</span>
                <span class="cov8" title="1">return rows, nil</span>
        }
        // Fallback to non-context version
        <span class="cov0" title="0">namedArgs := make([]driver.NamedValue, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                namedArgs[i] = driver.NamedValue{
                        Ordinal: i + 1,
                        Value:   arg,
                }
        }</span>
        //nolint:contextcheck // Using Background context for fallback when no context is available
        <span class="cov0" title="0">return c.QueryContext(context.Background(), query, namedArgs)</span>
}

type convertingStmt struct {
        driver.Stmt
}

func (s *convertingStmt) Exec(args []driver.Value) (driver.Result, error) <span class="cov0" title="0">{
        // Convert to context-aware version - this is the recommended approach
        namedArgs := make([]driver.NamedValue, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                namedArgs[i] = driver.NamedValue{
                        Ordinal: i + 1,
                        Value:   arg,
                }
        }</span>
        <span class="cov0" title="0">return s.ExecContext(context.Background(), namedArgs)</span>
}

func (s *convertingStmt) Query(args []driver.Value) (driver.Rows, error) <span class="cov0" title="0">{
        // Convert to context-aware version - this is the recommended approach
        namedArgs := make([]driver.NamedValue, len(args))
        for i, arg := range args </span><span class="cov0" title="0">{
                namedArgs[i] = driver.NamedValue{
                        Ordinal: i + 1,
                        Value:   arg,
                }
        }</span>
        <span class="cov0" title="0">return s.QueryContext(context.Background(), namedArgs)</span>
}

func (s *convertingStmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) <span class="cov0" title="0">{
        if stmtCtx, ok := s.Stmt.(driver.StmtExecContext); ok </span><span class="cov0" title="0">{
                convertedArgs := convertNamedValues(args)
                result, err := stmtCtx.ExecContext(ctx, convertedArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute statement with context: %w", err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }
        // Direct fallback without using deprecated methods
        <span class="cov0" title="0">convertedArgs := convertNamedValues(args)
        values := make([]driver.Value, len(convertedArgs))
        for i, arg := range convertedArgs </span><span class="cov0" title="0">{
                values[i] = arg.Value
        }</span>
        //nolint:staticcheck // Fallback required for drivers that don't implement StmtExecContext
        <span class="cov0" title="0">result, err := s.Stmt.Exec(values)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute statement: %w", err)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (s *convertingStmt) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) <span class="cov0" title="0">{
        if stmtCtx, ok := s.Stmt.(driver.StmtQueryContext); ok </span><span class="cov0" title="0">{
                convertedArgs := convertNamedValues(args)
                rows, err := stmtCtx.QueryContext(ctx, convertedArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to query statement with context: %w", err)
                }</span>
                <span class="cov0" title="0">return rows, nil</span>
        }
        // Direct fallback without using deprecated methods
        <span class="cov0" title="0">convertedArgs := convertNamedValues(args)
        values := make([]driver.Value, len(convertedArgs))
        for i, arg := range convertedArgs </span><span class="cov0" title="0">{
                values[i] = arg.Value
        }</span>
        //nolint:staticcheck // Fallback required for drivers that don't implement StmtQueryContext
        <span class="cov0" title="0">rows, err := s.Stmt.Query(values)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query statement: %w", err)
        }</span>
        <span class="cov0" title="0">return rows, nil</span>
}

// Convert driver.NamedValue slice
func convertNamedValues(args []driver.NamedValue) []driver.NamedValue <span class="cov8" title="1">{
        converted := make([]driver.NamedValue, len(args))

        for i, arg := range args </span><span class="cov8" title="1">{
                converted[i] = arg

                if timePtr, ok := arg.Value.(*time.Time); ok </span><span class="cov0" title="0">{
                        if timePtr == nil </span><span class="cov0" title="0">{
                                converted[i].Value = nil
                        }</span> else<span class="cov0" title="0"> {
                                converted[i].Value = *timePtr
                        }</span>
                } else<span class="cov8" title="1"> if isSlice(arg.Value) </span><span class="cov0" title="0">{
                        // Convert Go slices to DuckDB array format
                        if arrayStr, err := formatSliceForDuckDB(arg.Value); err == nil </span><span class="cov0" title="0">{
                                converted[i].Value = arrayStr
                        }</span>
                }
        }

        <span class="cov8" title="1">return converted</span>
}

// isSlice checks if a value is a slice (but not string or []byte)
func isSlice(v interface{}) bool <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">rv := reflect.ValueOf(v)
        if rv.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't treat strings or []byte as arrays
        <span class="cov0" title="0">switch v.(type) </span>{
        case string, []byte:<span class="cov0" title="0">
                return false</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// Initialize implements gorm.Dialector
func (dialector Dialector) Initialize(db *gorm.DB) error <span class="cov8" title="1">{
        callbacks.RegisterDefaultCallbacks(db, &amp;callbacks.Config{})

        // Override the create callback to use RETURNING for auto-increment fields
        if err := db.Callback().Create().Before("gorm:create").Register("duckdb:before_create", beforeCreateCallback); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register before create callback: %w", err)
        }</span>
        <span class="cov8" title="1">if err := db.Callback().Create().Replace("gorm:create", createCallback); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to replace create callback: %w", err)
        }</span>

        <span class="cov8" title="1">if dialector.DefaultStringSize == 0 </span><span class="cov8" title="1">{
                dialector.DefaultStringSize = 256
        }</span>

        <span class="cov8" title="1">if dialector.DriverName == "" </span><span class="cov8" title="1">{
                dialector.DriverName = "duckdb-gorm"
        }</span>

        <span class="cov8" title="1">if dialector.Conn != nil </span><span class="cov0" title="0">{
                db.ConnPool = dialector.Conn
        }</span> else<span class="cov8" title="1"> {
                connPool, err := sql.Open(dialector.DriverName, dialector.DSN)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open database connection: %w", err)
                }</span>
                <span class="cov8" title="1">db.ConnPool = connPool</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Migrator returns a new migrator instance for DuckDB.
func (dialector Dialector) Migrator(db *gorm.DB) gorm.Migrator <span class="cov8" title="1">{
        return Migrator{
                migrator.Migrator{
                        Config: migrator.Config{
                                DB:                          db,
                                Dialector:                   dialector,
                                CreateIndexAfterCreateTable: true,
                        },
                },
        }
}</span>

// DataTypeOf returns the SQL data type for a given field.
func (dialector Dialector) DataTypeOf(field *schema.Field) string <span class="cov8" title="1">{
        switch field.DataType </span>{
        case schema.Bool:<span class="cov0" title="0">
                return "BOOLEAN"</span>
        case schema.Int:<span class="cov0" title="0">
                switch field.Size </span>{
                case 8:<span class="cov0" title="0">
                        return "TINYINT"</span>
                case 16:<span class="cov0" title="0">
                        return "SMALLINT"</span>
                case 32:<span class="cov0" title="0">
                        return sqlTypeInteger</span>
                default:<span class="cov0" title="0">
                        return "BIGINT"</span>
                }
        case schema.Uint:<span class="cov8" title="1">
                // For primary keys, use INTEGER to enable auto-increment in DuckDB
                if field.PrimaryKey </span><span class="cov8" title="1">{
                        return sqlTypeInteger
                }</span>
                // Use signed integers for uint to ensure foreign key compatibility
                // DuckDB has issues with foreign keys between signed and unsigned types
                <span class="cov8" title="1">switch field.Size </span>{
                case 8:<span class="cov8" title="1">
                        return "TINYINT"</span>
                case 16:<span class="cov0" title="0">
                        return "SMALLINT"</span>
                case 32:<span class="cov0" title="0">
                        return sqlTypeInteger</span>
                default:<span class="cov0" title="0">
                        return "BIGINT"</span>
                }
        case schema.Float:<span class="cov0" title="0">
                if field.Size == 32 </span><span class="cov0" title="0">{
                        return "REAL"
                }</span>
                <span class="cov0" title="0">return "DOUBLE"</span>
        case schema.String:<span class="cov8" title="1">
                size := field.Size
                if size == 0 </span><span class="cov0" title="0">{
                        if dialector.DefaultStringSize &gt; 0 &amp;&amp; dialector.DefaultStringSize &lt;= 65535 </span><span class="cov0" title="0">{
                                size = int(dialector.DefaultStringSize) //nolint:gosec // Safe conversion, bounds already checked
                        }</span> else<span class="cov0" title="0"> {
                                size = 256 // Safe default
                        }</span>
                }
                <span class="cov8" title="1">if size &gt; 0 &amp;&amp; size &lt; 65536 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("VARCHAR(%d)", size)
                }</span>
                <span class="cov0" title="0">return "TEXT"</span>
        case schema.Time:<span class="cov8" title="1">
                return "TIMESTAMP"</span>
        case schema.Bytes:<span class="cov0" title="0">
                return "BLOB"</span>
        }

        // Check if it's an array type
        <span class="cov0" title="0">if strings.HasSuffix(string(field.DataType), "[]") </span><span class="cov0" title="0">{
                baseType := strings.TrimSuffix(string(field.DataType), "[]")
                return fmt.Sprintf("%s[]", baseType)
        }</span>

        <span class="cov0" title="0">return string(field.DataType)</span>
}

// DefaultValueOf returns the default value clause for a field.
func (dialector Dialector) DefaultValueOf(field *schema.Field) clause.Expression <span class="cov0" title="0">{
        if field.HasDefaultValue &amp;&amp; (field.DefaultValueInterface != nil || field.DefaultValue != "") </span><span class="cov0" title="0">{
                if field.DefaultValueInterface != nil </span><span class="cov0" title="0">{
                        switch v := field.DefaultValueInterface.(type) </span>{
                        case bool:<span class="cov0" title="0">
                                if v </span><span class="cov0" title="0">{
                                        return clause.Expr{SQL: "TRUE"}
                                }</span>
                                <span class="cov0" title="0">return clause.Expr{SQL: "FALSE"}</span>
                        default:<span class="cov0" title="0">
                                return clause.Expr{SQL: fmt.Sprintf("'%v'", field.DefaultValueInterface)}</span>
                        }
                } else<span class="cov0" title="0"> if field.DefaultValue != "" &amp;&amp; field.DefaultValue != "(-)" </span><span class="cov0" title="0">{
                        if field.DataType == schema.Bool </span><span class="cov0" title="0">{
                                if strings.ToLower(field.DefaultValue) == "true" </span><span class="cov0" title="0">{
                                        return clause.Expr{SQL: "TRUE"}
                                }</span>
                                <span class="cov0" title="0">return clause.Expr{SQL: "FALSE"}</span>
                        }
                        <span class="cov0" title="0">return clause.Expr{SQL: field.DefaultValue}</span>
                }
        }
        <span class="cov0" title="0">return clause.Expr{}</span>
}

// BindVarTo writes the bind variable to the clause writer.
func (dialector Dialector) BindVarTo(writer clause.Writer, _ *gorm.Statement, _ interface{}) <span class="cov8" title="1">{
        _ = writer.WriteByte('?')
}</span>

// QuoteTo writes quoted identifiers to the writer.
func (dialector Dialector) QuoteTo(writer clause.Writer, str string) <span class="cov8" title="1">{
        var (
                underQuoted, selfQuoted bool
                continuousBacktick      int8
                shiftDelimiter          int8
        )

        for _, v := range []byte(str) </span><span class="cov8" title="1">{
                switch v </span>{
                case '"':<span class="cov0" title="0">
                        continuousBacktick++
                        if continuousBacktick == 2 </span><span class="cov0" title="0">{
                                _, _ = writer.WriteString(`""`)
                                continuousBacktick = 0
                        }</span>
                case '.':<span class="cov0" title="0">
                        if continuousBacktick &gt; 0 || !selfQuoted </span><span class="cov0" title="0">{
                                shiftDelimiter = 0
                                underQuoted = false
                                continuousBacktick = 0
                                _ = writer.WriteByte('"')
                        }</span>
                        <span class="cov0" title="0">_ = writer.WriteByte(v)
                        continue</span>
                default:<span class="cov8" title="1">
                        if shiftDelimiter-continuousBacktick &lt;= 0 &amp;&amp; !underQuoted </span><span class="cov8" title="1">{
                                _ = writer.WriteByte('"')
                                underQuoted = true
                                if selfQuoted = continuousBacktick &gt; 0; selfQuoted </span><span class="cov0" title="0">{
                                        continuousBacktick--
                                }</span>
                        }

                        <span class="cov8" title="1">for ; continuousBacktick &gt; 0; continuousBacktick-- </span><span class="cov0" title="0">{
                                _, _ = writer.WriteString(`""`)
                        }</span>

                        <span class="cov8" title="1">_ = writer.WriteByte(v)</span>
                }
                <span class="cov8" title="1">shiftDelimiter++</span>
        }

        <span class="cov8" title="1">if continuousBacktick &gt; 0 &amp;&amp; !selfQuoted </span><span class="cov0" title="0">{
                _, _ = writer.WriteString(`""`)
        }</span>
        <span class="cov8" title="1">_ = writer.WriteByte('"')</span>
}

// Explain returns an explanation of the SQL query.
func (dialector Dialector) Explain(sql string, vars ...interface{}) string <span class="cov0" title="0">{
        return logger.ExplainSQL(sql, nil, `"`, vars...)
}</span>

// SavePoint creates a savepoint with the given name.
func (dialector Dialector) SavePoint(tx *gorm.DB, name string) error <span class="cov0" title="0">{
        return tx.Exec("SAVEPOINT " + name).Error
}</span>

// RollbackTo rolls back to the given savepoint.
func (dialector Dialector) RollbackTo(tx *gorm.DB, name string) error <span class="cov0" title="0">{
        return tx.Exec("ROLLBACK TO SAVEPOINT " + name).Error
}</span>

// beforeCreateCallback prepares the statement for auto-increment handling
func beforeCreateCallback(_ *gorm.DB) {<span class="cov8" title="1">
        // Nothing special needed here, just ensuring the statement is prepared
}</span>

// createCallback handles INSERT operations with RETURNING for auto-increment fields
func createCallback(db *gorm.DB) <span class="cov8" title="1">{
        if db.Error != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if db.Statement.Schema != nil </span><span class="cov8" title="1">{
                var hasAutoIncrement bool
                var autoIncrementField *schema.Field

                // Check if we have auto-increment primary key
                for _, field := range db.Statement.Schema.PrimaryFields </span><span class="cov8" title="1">{
                        if field.AutoIncrement </span><span class="cov8" title="1">{
                                hasAutoIncrement = true
                                autoIncrementField = field
                                break</span>
                        }
                }

                <span class="cov8" title="1">if hasAutoIncrement </span><span class="cov8" title="1">{
                        // Build custom INSERT with RETURNING
                        sql, vars := buildInsertSQL(db, autoIncrementField)
                        if sql != "" </span><span class="cov8" title="1">{
                                // Execute with RETURNING to get the auto-generated ID
                                var id int64
                                if err := db.Raw(sql, vars...).Row().Scan(&amp;id); err != nil </span><span class="cov8" title="1">{
                                        if addErr := db.AddError(err); addErr != nil </span><span class="cov8" title="1">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">return</span>
                                }

                                // Set the ID in the model using GORM's ReflectValue
                                <span class="cov8" title="1">if db.Statement.ReflectValue.IsValid() &amp;&amp; db.Statement.ReflectValue.CanAddr() </span><span class="cov8" title="1">{
                                        modelValue := db.Statement.ReflectValue

                                        if idField := modelValue.FieldByName(autoIncrementField.Name); idField.IsValid() &amp;&amp; idField.CanSet() </span><span class="cov8" title="1">{
                                                // Handle different integer types
                                                switch idField.Kind() </span>{
                                                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                                                        if id &gt;= 0 </span><span class="cov8" title="1">{
                                                                idField.SetUint(uint64(id))
                                                        }</span>
                                                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                                                        idField.SetInt(id)</span>
                                                }
                                        }
                                }

                                <span class="cov8" title="1">db.Statement.RowsAffected = 1
                                return</span>
                        }
                }
        }

        // Fall back to default behavior for non-auto-increment cases
        <span class="cov0" title="0">if db.Statement.SQL.String() == "" </span><span class="cov0" title="0">{
                db.Statement.Build("INSERT")
        }</span>

        <span class="cov0" title="0">if result, err := db.Statement.ConnPool.ExecContext(db.Statement.Context, db.Statement.SQL.String(), db.Statement.Vars...); err != nil </span><span class="cov0" title="0">{
                if addErr := db.AddError(err); addErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                if rows, _ := result.RowsAffected(); rows &gt; 0 </span><span class="cov0" title="0">{
                        db.Statement.RowsAffected = rows
                }</span>
        }
}

// buildInsertSQL creates an INSERT statement with RETURNING for auto-increment fields
func buildInsertSQL(db *gorm.DB, autoIncrementField *schema.Field) (string, []interface{}) <span class="cov8" title="1">{
        if db.Statement.Schema == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">fieldCount := len(db.Statement.Schema.Fields)
        fields := make([]string, 0, fieldCount)
        placeholders := make([]string, 0, fieldCount)
        values := make([]interface{}, 0, fieldCount)

        // Build field list excluding auto-increment field
        for _, field := range db.Statement.Schema.Fields </span><span class="cov8" title="1">{
                if field.DBName == autoIncrementField.DBName </span><span class="cov8" title="1">{
                        continue</span> // Skip auto-increment field
                }

                // Get the value for this field
                <span class="cov8" title="1">fieldValue := db.Statement.ReflectValue.FieldByName(field.Name)
                if !fieldValue.IsValid() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // For optional fields, skip zero values
                <span class="cov8" title="1">if field.HasDefaultValue &amp;&amp; fieldValue.Kind() != reflect.String &amp;&amp; fieldValue.IsZero() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">fields = append(fields, db.Statement.Quote(field.DBName))
                placeholders = append(placeholders, "?")
                values = append(values, fieldValue.Interface())</span>
        }

        <span class="cov8" title="1">if len(fields) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">tableName := db.Statement.Quote(db.Statement.Table)
        sql := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s",
                tableName,
                strings.Join(fields, ", "),
                strings.Join(placeholders, ", "),
                db.Statement.Quote(autoIncrementField.DBName))

        return sql, values</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package duckdb

import (
        "errors"
        "strings"

        "gorm.io/gorm"
)

// ErrorTranslator implements gorm.ErrorTranslator for DuckDB
type ErrorTranslator struct{}

// Translate converts DuckDB errors to GORM errors
func (et ErrorTranslator) Translate(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">errStr := err.Error()
        errStrLower := strings.ToLower(errStr)

        // Handle DuckDB specific errors
        switch </span>{
        case strings.Contains(errStrLower, "unique constraint"):<span class="cov0" title="0">
                return gorm.ErrDuplicatedKey</span>
        case strings.Contains(errStrLower, "foreign key constraint"):<span class="cov0" title="0">
                return gorm.ErrForeignKeyViolated</span>
        case strings.Contains(errStrLower, "check constraint"):<span class="cov0" title="0">
                return gorm.ErrCheckConstraintViolated</span>
        case strings.Contains(errStrLower, "not null constraint"):<span class="cov0" title="0">
                return gorm.ErrInvalidValue</span>
        case strings.Contains(errStrLower, "no such table"):<span class="cov0" title="0">
                return gorm.ErrRecordNotFound</span>
        case strings.Contains(errStrLower, "no such column"):<span class="cov0" title="0">
                return gorm.ErrInvalidField</span>
        case strings.Contains(errStrLower, "syntax error"):<span class="cov0" title="0">
                return gorm.ErrInvalidData</span>
        case strings.Contains(errStrLower, "connection"):<span class="cov0" title="0">
                return gorm.ErrInvalidDB</span>
        case strings.Contains(errStrLower, "database is locked"):<span class="cov0" title="0">
                return gorm.ErrInvalidDB</span>
        }

        // Check for specific DuckDB error patterns
        <span class="cov0" title="0">if strings.Contains(errStrLower, "constraint") </span><span class="cov0" title="0">{
                return gorm.ErrInvalidValue
        }</span>

        <span class="cov0" title="0">if strings.Contains(errStrLower, "invalid") || strings.Contains(errStrLower, "malformed") </span><span class="cov0" title="0">{
                return gorm.ErrInvalidData
        }</span>

        // Default to the original error if no specific translation is found
        <span class="cov0" title="0">return err</span>
}

// Common DuckDB error patterns
var (
        ErrUniqueConstraint  = errors.New("UNIQUE constraint failed")
        ErrForeignKey        = errors.New("FOREIGN KEY constraint failed")
        ErrCheckConstraint   = errors.New("CHECK constraint failed")
        ErrNotNullConstraint = errors.New("NOT NULL constraint failed")
        ErrNoSuchTable       = errors.New("no such table")
        ErrNoSuchColumn      = errors.New("no such column")
        ErrSyntaxError       = errors.New("syntax error")
        ErrDatabaseLocked    = errors.New("database is locked")
)

// IsSpecificError checks if an error matches a specific DuckDB error type
func IsSpecificError(err error, target error) bool <span class="cov0" title="0">{
        if err == nil || target == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">errStr := strings.ToLower(err.Error())
        targetStr := strings.ToLower(target.Error())

        return strings.Contains(errStr, targetStr)</span>
}

// IsDuplicateKeyError checks if the error is a duplicate key constraint violation
func IsDuplicateKeyError(err error) bool <span class="cov0" title="0">{
        return IsSpecificError(err, ErrUniqueConstraint)
}</span>

// IsForeignKeyError checks if the error is a foreign key constraint violation
func IsForeignKeyError(err error) bool <span class="cov0" title="0">{
        return IsSpecificError(err, ErrForeignKey)
}</span>

// IsNotNullError checks if the error is a not null constraint violation
func IsNotNullError(err error) bool <span class="cov0" title="0">{
        return IsSpecificError(err, ErrNotNullConstraint)
}</span>

// IsTableNotFoundError checks if the error is a table not found error
func IsTableNotFoundError(err error) bool <span class="cov0" title="0">{
        return IsSpecificError(err, ErrNoSuchTable)
}</span>

// IsColumnNotFoundError checks if the error is a column not found error
func IsColumnNotFoundError(err error) bool <span class="cov0" title="0">{
        return IsSpecificError(err, ErrNoSuchColumn)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package duckdb

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "gorm.io/gorm"
)

// Extension represents a DuckDB extension with its metadata and status
type Extension struct {
        Name        string `json:"name"`
        Description string `json:"description,omitempty"`
        Loaded      bool   `json:"loaded"`
        Installed   bool   `json:"installed"`
        BuiltIn     bool   `json:"built_in,omitempty"`
        Version     string `json:"version,omitempty"`
}

// ExtensionConfig holds configuration for extension management
type ExtensionConfig struct {
        // AutoInstall automatically installs extensions when loading
        AutoInstall bool

        // PreloadExtensions list of extensions to load on database connection
        PreloadExtensions []string

        // Timeout for extension operations (0 = no timeout)
        Timeout time.Duration

        // RepositoryURL custom extension repository URL
        RepositoryURL string

        // AllowUnsigned allows loading unsigned extensions (security risk)
        AllowUnsigned bool
}

// ExtensionManager handles DuckDB extension operations
type ExtensionManager struct {
        db     *gorm.DB
        config *ExtensionConfig
}

// Common DuckDB extensions
const (
        // Core Extensions (built-in)
        ExtensionJSON    = "json"
        ExtensionParquet = "parquet"
        ExtensionICU     = "icu"

        // Analytics Extensions
        ExtensionAutoComplete = "autocomplete"
        ExtensionFTS          = "fts"
        ExtensionTPCH         = "tpch"
        ExtensionTPCDS        = "tpcds"

        // Data Format Extensions
        ExtensionCSV    = "csv"
        ExtensionExcel  = "excel"
        ExtensionArrow  = "arrow"
        ExtensionSQLite = "sqlite"

        // Networking Extensions
        ExtensionHTTPS = "httpfs"
        ExtensionS3    = "aws"
        ExtensionAzure = "azure"

        // Geospatial Extensions
        ExtensionSpatial = "spatial"

        // Machine Learning Extensions
        ExtensionML = "ml"

        // Time Series Extensions
        ExtensionTimeSeries = "timeseries"

        // Visualization Extensions
        ExtensionVisualization = "visualization"
)

// NewExtensionManager creates a new extension manager instance
func NewExtensionManager(db *gorm.DB, config *ExtensionConfig) *ExtensionManager <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;ExtensionConfig{
                        AutoInstall: true,
                        Timeout:     30 * time.Second,
                }
        }</span>

        <span class="cov0" title="0">return &amp;ExtensionManager{
                db:     db,
                config: config,
        }</span>
}

// ListExtensions returns all available extensions
func (m *ExtensionManager) ListExtensions() ([]Extension, error) <span class="cov0" title="0">{
        ctx := context.Background()
        if m.config.Timeout &gt; 0 </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, m.config.Timeout)
                defer cancel()
        }</span>

        <span class="cov0" title="0">var extensions []Extension

        // Query duckdb_extensions() function to get extension information
        query := `
                SELECT 
                        extension_name as name,
                        loaded,
                        installed,
                        description
                FROM duckdb_extensions()
                ORDER BY extension_name
        `

        rows, err := m.db.WithContext(ctx).Raw(query).Rows()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query extensions: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = rows.Close()
        }</span>()

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var ext Extension
                var description sql.NullString

                if err := rows.Scan(&amp;ext.Name, &amp;ext.Loaded, &amp;ext.Installed, &amp;description); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan extension row: %w", err)
                }</span>

                <span class="cov0" title="0">if description.Valid </span><span class="cov0" title="0">{
                        ext.Description = description.String
                }</span>

                <span class="cov0" title="0">extensions = append(extensions, ext)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating extension rows: %w", err)
        }</span>

        <span class="cov0" title="0">return extensions, nil</span>
}

// GetExtension returns information about a specific extension
func (m *ExtensionManager) GetExtension(name string) (*Extension, error) <span class="cov0" title="0">{
        ctx := context.Background()
        if m.config.Timeout &gt; 0 </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, m.config.Timeout)
                defer cancel()
        }</span>

        <span class="cov0" title="0">query := `
                SELECT 
                        extension_name as name,
                        loaded,
                        installed,
                        description
                FROM duckdb_extensions()
                WHERE extension_name = ?
        `

        var ext Extension
        var description sql.NullString

        err := m.db.WithContext(ctx).Raw(query, name).Row().Scan(
                &amp;ext.Name, &amp;ext.Loaded, &amp;ext.Installed, &amp;description,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("extension '%s' not found", name)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get extension '%s': %w", name, err)</span>
        }

        <span class="cov0" title="0">if description.Valid </span><span class="cov0" title="0">{
                ext.Description = description.String
        }</span>

        <span class="cov0" title="0">return &amp;ext, nil</span>
}

// LoadExtension loads an extension, optionally installing it first
func (m *ExtensionManager) LoadExtension(name string) error <span class="cov0" title="0">{
        ctx := context.Background()
        if m.config.Timeout &gt; 0 </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, m.config.Timeout)
                defer cancel()
        }</span>

        // Check if extension is already loaded
        <span class="cov0" title="0">if m.IsExtensionLoaded(name) </span><span class="cov0" title="0">{
                return nil // Already loaded
        }</span>

        // Install extension if auto-install is enabled and extension is not installed
        <span class="cov0" title="0">if m.config.AutoInstall </span><span class="cov0" title="0">{
                ext, err := m.GetExtension(name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check extension status: %w", err)
                }</span>

                <span class="cov0" title="0">if !ext.Installed </span><span class="cov0" title="0">{
                        if err := m.InstallExtension(name); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to install extension '%s': %w", name, err)
                        }</span>
                }
        }

        // Load the extension
        <span class="cov0" title="0">query := fmt.Sprintf("LOAD %s", m.quoteName(name))
        if err := m.db.WithContext(ctx).Exec(query).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load extension '%s': %w", name, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// InstallExtension installs an extension from the repository
func (m *ExtensionManager) InstallExtension(name string) error <span class="cov0" title="0">{
        ctx := context.Background()
        if m.config.Timeout &gt; 0 </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, m.config.Timeout)
                defer cancel()
        }</span>

        // Check if already installed
        <span class="cov0" title="0">ext, err := m.GetExtension(name)
        if err == nil &amp;&amp; ext.Installed </span><span class="cov0" title="0">{
                return nil // Already installed
        }</span>

        // Install the extension
        <span class="cov0" title="0">query := fmt.Sprintf("INSTALL %s", m.quoteName(name))
        if err := m.db.WithContext(ctx).Exec(query).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install extension '%s': %w", name, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// IsExtensionLoaded checks if an extension is currently loaded
func (m *ExtensionManager) IsExtensionLoaded(name string) bool <span class="cov0" title="0">{
        ext, err := m.GetExtension(name)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return ext.Loaded</span>
}

// GetLoadedExtensions returns all currently loaded extensions
func (m *ExtensionManager) GetLoadedExtensions() ([]Extension, error) <span class="cov0" title="0">{
        extensions, err := m.ListExtensions()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var loaded []Extension
        for _, ext := range extensions </span><span class="cov0" title="0">{
                if ext.Loaded </span><span class="cov0" title="0">{
                        loaded = append(loaded, ext)
                }</span>
        }

        <span class="cov0" title="0">return loaded, nil</span>
}

// LoadExtensions loads multiple extensions
func (m *ExtensionManager) LoadExtensions(names []string) error <span class="cov0" title="0">{
        for _, name := range names </span><span class="cov0" title="0">{
                if err := m.LoadExtension(name); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load extension '%s': %w", name, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// PreloadExtensions loads all configured preload extensions
func (m *ExtensionManager) PreloadExtensions() error <span class="cov0" title="0">{
        if len(m.config.PreloadExtensions) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return m.LoadExtensions(m.config.PreloadExtensions)</span>
}

// quoteName safely quotes an extension name for SQL
func (m *ExtensionManager) quoteName(name string) string <span class="cov0" title="0">{
        // Remove any potentially dangerous characters
        cleaned := strings.ReplaceAll(name, "'", "")
        cleaned = strings.ReplaceAll(cleaned, "\"", "")
        cleaned = strings.ReplaceAll(cleaned, ";", "")
        cleaned = strings.ReplaceAll(cleaned, "--", "")
        return cleaned
}</span>

// ExtensionHelper provides convenience methods for common extension operations
type ExtensionHelper struct {
        manager *ExtensionManager
}

// NewExtensionHelper creates a new extension helper
func NewExtensionHelper(manager *ExtensionManager) *ExtensionHelper <span class="cov0" title="0">{
        return &amp;ExtensionHelper{manager: manager}
}</span>

// EnableAnalytics loads common analytics extensions
func (h *ExtensionHelper) EnableAnalytics() error <span class="cov0" title="0">{
        analyticsExtensions := []string{
                ExtensionJSON,
                ExtensionParquet,
                ExtensionFTS,
                ExtensionAutoComplete,
        }

        return h.manager.LoadExtensions(analyticsExtensions)
}</span>

// EnableDataFormats loads common data format extensions
func (h *ExtensionHelper) EnableDataFormats() error <span class="cov0" title="0">{
        // Only try to load extensions that are commonly available
        formatExtensions := []string{
                ExtensionJSON,
                ExtensionParquet,
        }

        // Try to load other extensions, but don't fail if they're not available
        optionalExtensions := []string{
                ExtensionCSV,
                ExtensionExcel,
                ExtensionArrow,
        }

        // Load essential extensions first
        if err := h.manager.LoadExtensions(formatExtensions); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Try optional extensions, log failures but don't return error
        <span class="cov0" title="0">for _, ext := range optionalExtensions </span><span class="cov0" title="0">{
                if err := h.manager.LoadExtension(ext); err != nil </span><span class="cov0" title="0">{
                        // Log but don't fail - these might not be available in all builds
                        continue</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// EnableCloudAccess loads cloud storage extensions
func (h *ExtensionHelper) EnableCloudAccess() error <span class="cov0" title="0">{
        cloudExtensions := []string{
                ExtensionHTTPS,
                ExtensionS3,
                ExtensionAzure,
        }

        return h.manager.LoadExtensions(cloudExtensions)
}</span>

// EnableSpatial loads geospatial extensions
func (h *ExtensionHelper) EnableSpatial() error <span class="cov0" title="0">{
        return h.manager.LoadExtension(ExtensionSpatial)
}</span>

// EnableMachineLearning loads ML extensions
func (h *ExtensionHelper) EnableMachineLearning() error <span class="cov0" title="0">{
        return h.manager.LoadExtension(ExtensionML)
}</span>

// EnableTimeSeries loads time series extensions
func (h *ExtensionHelper) EnableTimeSeries() error <span class="cov0" title="0">{
        return h.manager.LoadExtension(ExtensionTimeSeries)
}</span>

// Dialector integration for extensions

// extensionAwareDialector wraps the standard dialector with extension support
type extensionAwareDialector struct {
        *Dialector
        extensionConfig *ExtensionConfig
        manager         *ExtensionManager
}

// NewWithExtensions creates a new dialector with extension support
func NewWithExtensions(config Config, extensionConfig *ExtensionConfig) gorm.Dialector <span class="cov0" title="0">{
        return &amp;extensionAwareDialector{
                Dialector:       &amp;Dialector{Config: &amp;config},
                extensionConfig: extensionConfig,
        }
}</span>

// OpenWithExtensions creates a dialector with extension support using DSN
func OpenWithExtensions(dsn string, extensionConfig *ExtensionConfig) gorm.Dialector <span class="cov0" title="0">{
        return NewWithExtensions(Config{DSN: dsn}, extensionConfig)
}</span>

// Initialize initializes the dialector with extension support
func (d *extensionAwareDialector) Initialize(db *gorm.DB) error <span class="cov0" title="0">{
        // First initialize the base dialector
        if err := d.Dialector.Initialize(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create and store extension manager
        <span class="cov0" title="0">if d.extensionConfig != nil </span><span class="cov0" title="0">{
                d.manager = NewExtensionManager(db, d.extensionConfig)

                // Store manager in db instance for later retrieval
                db.InstanceSet("duckdb:extension_manager", d.manager)

                // Preload configured extensions
                if err := d.manager.PreloadExtensions(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to preload extensions: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Extension manager retrieval functions

// GetExtensionManager retrieves the extension manager from a database instance
func GetExtensionManager(db *gorm.DB) (*ExtensionManager, error) <span class="cov0" title="0">{
        if value, ok := db.InstanceGet("duckdb:extension_manager"); ok </span><span class="cov0" title="0">{
                if manager, ok := value.(*ExtensionManager); ok </span><span class="cov0" title="0">{
                        return manager, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("extension manager not found - use NewWithExtensions or OpenWithExtensions")</span>
}

// MustGetExtensionManager retrieves the extension manager, panics if not found
func MustGetExtensionManager(db *gorm.DB) *ExtensionManager <span class="cov0" title="0">{
        manager, err := GetExtensionManager(db)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return manager</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package duckdb

import (
        "fmt"
        "strings"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        "gorm.io/gorm/migrator"
        "gorm.io/gorm/schema"
)

const (
        // SQL data type constants
        sqlTypeBigInt  = "BIGINT"
        sqlTypeInteger = "INTEGER"
)

// Migrator implements gorm.Migrator interface for DuckDB database.
type Migrator struct {
        migrator.Migrator
}

// CurrentDatabase returns the current database name.
func (m Migrator) CurrentDatabase() (name string) <span class="cov0" title="0">{
        _ = m.DB.Raw("SELECT current_database()").Row().Scan(&amp;name)
        return
}</span>

// FullDataTypeOf returns the full data type for a field including constraints.
// Override FullDataTypeOf to prevent GORM from adding duplicate PRIMARY KEY clauses
func (m Migrator) FullDataTypeOf(field *schema.Field) clause.Expr <span class="cov8" title="1">{
        // Get the base data type from our dialector
        dataType := m.Dialector.DataTypeOf(field)

        expr := clause.Expr{SQL: dataType}

        // For primary key fields, ensure clean type definition without duplicate PRIMARY KEY
        if field.PrimaryKey </span><span class="cov8" title="1">{
                // For DuckDB auto-increment primary keys, use a sequence-based approach
                // Check if this is an auto-increment field (no default value specified)
                if field.AutoIncrement || (!field.HasDefaultValue &amp;&amp; field.DataType == schema.Uint) </span><span class="cov8" title="1">{
                        // Use BIGINT with a default sequence value
                        expr.SQL = "BIGINT DEFAULT nextval('seq_" + strings.ToLower(field.Schema.Table) + "_" + strings.ToLower(field.DBName) + "')"
                }</span> else<span class="cov0" title="0"> {
                        // Make sure the data type is clean for non-auto-increment primary keys
                        upperDataType := strings.ToUpper(dataType)
                        switch </span>{
                        case strings.Contains(upperDataType, sqlTypeBigInt):<span class="cov0" title="0">
                                expr.SQL = sqlTypeBigInt</span>
                        case strings.Contains(upperDataType, sqlTypeInteger):<span class="cov0" title="0">
                                expr.SQL = sqlTypeInteger</span>
                        default:<span class="cov0" title="0">
                                expr.SQL = dataType</span>
                        }
                }

                // Add NOT NULL for primary keys
                <span class="cov8" title="1">expr.SQL += " NOT NULL"

                // Do NOT add PRIMARY KEY here - let GORM handle it in the table definition
                return expr</span>
        }

        // For non-primary key fields, add constraints
        <span class="cov8" title="1">if field.NotNull </span><span class="cov8" title="1">{
                expr.SQL += " NOT NULL"
        }</span>

        <span class="cov8" title="1">if field.Unique </span><span class="cov0" title="0">{
                expr.SQL += " UNIQUE"
        }</span>

        // Handle defaults for non-primary key fields only
        <span class="cov8" title="1">if field.HasDefaultValue &amp;&amp; (field.DefaultValueInterface != nil || field.DefaultValue != "") </span><span class="cov0" title="0">{
                if field.DefaultValueInterface != nil </span><span class="cov0" title="0">{
                        defaultStmt := &amp;gorm.Statement{Vars: []interface{}{field.DefaultValueInterface}}
                        m.BindVarTo(defaultStmt, defaultStmt, field.DefaultValueInterface)
                        expr.SQL += " DEFAULT " + m.Explain(defaultStmt.SQL.String(), field.DefaultValueInterface)
                }</span> else<span class="cov0" title="0"> if field.DefaultValue != "(-)" </span><span class="cov0" title="0">{
                        expr.SQL += " DEFAULT " + field.DefaultValue
                }</span>
        }

        <span class="cov8" title="1">if field.Comment != "" </span><span class="cov0" title="0">{
                expr.SQL += " COMMENT '" + field.Comment + "'"
        }</span>

        <span class="cov8" title="1">return expr</span>
}

// AlterColumn modifies a column definition in DuckDB, handling syntax limitations.
func (m Migrator) AlterColumn(value interface{}, field string) error <span class="cov0" title="0">{
        err := m.RunWithValue(value, func(stmt *gorm.Statement) error </span><span class="cov0" title="0">{
                if stmt.Schema != nil </span><span class="cov0" title="0">{
                        if field := stmt.Schema.LookUpField(field); field != nil </span><span class="cov0" title="0">{
                                // For ALTER COLUMN, only use the base data type without defaults
                                baseType := m.Dialector.DataTypeOf(field)

                                // Clean the base type - remove any DEFAULT clauses
                                baseType = strings.Split(baseType, " DEFAULT")[0]

                                return m.DB.Exec(
                                        "ALTER TABLE ? ALTER COLUMN ? TYPE ?",
                                        m.CurrentTable(stmt), clause.Column{Name: field.DBName}, clause.Expr{SQL: baseType},
                                ).Error
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("failed to look up field with name: %s", field)</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to alter column: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RenameColumn renames a column in the database table.
func (m Migrator) RenameColumn(value interface{}, oldName, newName string) error <span class="cov0" title="0">{
        err := m.RunWithValue(value, func(stmt *gorm.Statement) error </span><span class="cov0" title="0">{
                if stmt.Schema != nil </span><span class="cov0" title="0">{
                        if field := stmt.Schema.LookUpField(oldName); field != nil </span><span class="cov0" title="0">{
                                oldName = field.DBName
                        }</span>

                        <span class="cov0" title="0">if field := stmt.Schema.LookUpField(newName); field != nil </span><span class="cov0" title="0">{
                                newName = field.DBName
                        }</span>
                }

                <span class="cov0" title="0">return m.DB.Exec(
                        "ALTER TABLE ? RENAME COLUMN ? TO ?",
                        m.CurrentTable(stmt), clause.Column{Name: oldName}, clause.Column{Name: newName},
                ).Error</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rename column: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RenameIndex renames an index in the database.
func (m Migrator) RenameIndex(value interface{}, oldName, newName string) error <span class="cov0" title="0">{
        err := m.RunWithValue(value, func(_ *gorm.Statement) error </span><span class="cov0" title="0">{
                return m.DB.Exec(
                        "ALTER INDEX ? RENAME TO ?",
                        clause.Column{Name: oldName}, clause.Column{Name: newName},
                ).Error
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rename index: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DropIndex drops an index from the database.
func (m Migrator) DropIndex(value interface{}, name string) error <span class="cov0" title="0">{
        err := m.RunWithValue(value, func(stmt *gorm.Statement) error </span><span class="cov0" title="0">{
                if stmt.Schema != nil </span><span class="cov0" title="0">{
                        if idx := stmt.Schema.LookIndex(name); idx != nil </span><span class="cov0" title="0">{
                                name = idx.Name
                        }</span>
                }

                <span class="cov0" title="0">return m.DB.Exec("DROP INDEX IF EXISTS ?", clause.Column{Name: name}).Error</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop index: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DropConstraint drops a constraint from the database.
func (m Migrator) DropConstraint(value interface{}, name string) error <span class="cov0" title="0">{
        err := m.RunWithValue(value, func(stmt *gorm.Statement) error </span><span class="cov0" title="0">{
                constraint, table := m.GuessConstraintInterfaceAndTable(stmt, name)
                if constraint != nil </span><span class="cov0" title="0">{
                        name = constraint.GetName()
                }</span>
                <span class="cov0" title="0">return m.Migrator.DB.Exec("ALTER TABLE ? DROP CONSTRAINT ?", clause.Table{Name: table}, clause.Column{Name: name}).Error</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop constraint: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// HasTable checks if a table exists in the database.
func (m Migrator) HasTable(value interface{}) bool <span class="cov8" title="1">{
        var count int64

        _ = m.RunWithValue(value, func(stmt *gorm.Statement) error </span><span class="cov8" title="1">{
                return m.DB.Raw(
                        "SELECT count(*) FROM information_schema.tables WHERE table_name = ? AND table_type = 'BASE TABLE'",
                        stmt.Table,
                ).Row().Scan(&amp;count)
        }</span>)

        <span class="cov8" title="1">return count &gt; 0</span>
}

// GetTables returns a list of all table names in the database.
func (m Migrator) GetTables() (tableList []string, err error) <span class="cov0" title="0">{
        err = m.DB.Raw(
                "SELECT table_name FROM information_schema.tables WHERE table_type = 'BASE TABLE'",
        ).Scan(&amp;tableList).Error
        return
}</span>

// HasColumn checks if a column exists in the database table.
func (m Migrator) HasColumn(value interface{}, field string) bool <span class="cov0" title="0">{
        var count int64
        _ = m.RunWithValue(value, func(stmt *gorm.Statement) error </span><span class="cov0" title="0">{
                name := field
                if stmt.Schema != nil </span><span class="cov0" title="0">{
                        if field := stmt.Schema.LookUpField(field); field != nil </span><span class="cov0" title="0">{
                                name = field.DBName
                        }</span>
                }

                <span class="cov0" title="0">return m.DB.Raw(
                        "SELECT count(*) FROM information_schema.columns WHERE table_name = ? AND column_name = ?",
                        stmt.Table, name,
                ).Row().Scan(&amp;count)</span>
        })

        <span class="cov0" title="0">return count &gt; 0</span>
}

// HasIndex checks if an index exists in the database.
func (m Migrator) HasIndex(value interface{}, name string) bool <span class="cov0" title="0">{
        var count int64
        _ = m.RunWithValue(value, func(stmt *gorm.Statement) error </span><span class="cov0" title="0">{
                if stmt.Schema != nil </span><span class="cov0" title="0">{
                        if idx := stmt.Schema.LookIndex(name); idx != nil </span><span class="cov0" title="0">{
                                name = idx.Name
                        }</span>
                }

                <span class="cov0" title="0">return m.DB.Raw(
                        "SELECT count(*) FROM information_schema.statistics WHERE table_name = ? AND index_name = ?",
                        stmt.Table, name,
                ).Row().Scan(&amp;count)</span>
        })

        <span class="cov0" title="0">return count &gt; 0</span>
}

// HasConstraint checks if a constraint exists in the database.
func (m Migrator) HasConstraint(value interface{}, name string) bool <span class="cov0" title="0">{
        var count int64
        _ = m.RunWithValue(value, func(stmt *gorm.Statement) error </span><span class="cov0" title="0">{
                constraint, table := m.GuessConstraintInterfaceAndTable(stmt, name)
                if constraint != nil </span><span class="cov0" title="0">{
                        name = constraint.GetName()
                }</span>

                <span class="cov0" title="0">return m.DB.Raw(
                        "SELECT count(*) FROM information_schema.table_constraints WHERE table_name = ? AND constraint_name = ?",
                        table, name,
                ).Row().Scan(&amp;count)</span>
        })

        <span class="cov0" title="0">return count &gt; 0</span>
}

// CreateView creates a database view.
func (m Migrator) CreateView(name string, option gorm.ViewOption) error <span class="cov0" title="0">{
        if option.Query == nil </span><span class="cov0" title="0">{
                return gorm.ErrSubQueryRequired
        }</span>

        <span class="cov0" title="0">sql := new(strings.Builder)
        sql.WriteString("CREATE ")
        if option.Replace </span><span class="cov0" title="0">{
                sql.WriteString("OR REPLACE ")
        }</span>
        <span class="cov0" title="0">sql.WriteString("VIEW ")
        m.QuoteTo(sql, name)
        sql.WriteString(" AS ")

        m.DB.Statement.AddVar(sql, option.Query)

        if option.CheckOption != "" </span><span class="cov0" title="0">{
                sql.WriteString(" ")
                sql.WriteString(option.CheckOption)
        }</span>

        <span class="cov0" title="0">return m.DB.Exec(m.Explain(sql.String(), m.DB.Statement.Vars...)).Error</span>
}

// DropView drops a database view.
func (m Migrator) DropView(name string) error <span class="cov0" title="0">{
        return m.DB.Exec("DROP VIEW IF EXISTS ?", clause.Table{Name: name}).Error
}</span>

// GetTypeAliases returns type aliases for the given database type name.
func (m Migrator) GetTypeAliases(databaseTypeName string) []string <span class="cov0" title="0">{
        aliases := map[string][]string{
                "boolean":   {"bool"},
                "tinyint":   {"int8"},
                "smallint":  {"int16"},
                "integer":   {"int", "int32"},
                "bigint":    {"int64"},
                "utinyint":  {"uint8"},
                "usmallint": {"uint16"},
                "uinteger":  {"uint", "uint32"},
                "ubigint":   {"uint64"},
                "real":      {"float32"},
                "double":    {"float64", "float"},
                "varchar":   {"string"},
                "text":      {"string"},
                "blob":      {"bytes"},
                "timestamp": {"time"},
        }

        return aliases[databaseTypeName]
}</span>

// CreateTable overrides the default CreateTable to handle DuckDB-specific auto-increment sequences
func (m Migrator) CreateTable(values ...interface{}) error <span class="cov8" title="1">{
        for _, value := range values </span><span class="cov8" title="1">{
                if err := m.RunWithValue(value, func(stmt *gorm.Statement) error </span><span class="cov8" title="1">{
                        // First, create sequences for auto-increment primary key fields
                        if stmt.Schema != nil </span><span class="cov8" title="1">{
                                for _, field := range stmt.Schema.Fields </span><span class="cov8" title="1">{
                                        if field.PrimaryKey &amp;&amp; (field.AutoIncrement || (!field.HasDefaultValue &amp;&amp; field.DataType == schema.Uint)) </span><span class="cov8" title="1">{
                                                sequenceName := "seq_" + strings.ToLower(stmt.Schema.Table) + "_" + strings.ToLower(field.DBName)
                                                createSeqSQL := fmt.Sprintf("CREATE SEQUENCE IF NOT EXISTS %s START 1", sequenceName)
                                                if err := m.DB.Exec(createSeqSQL).Error; err != nil </span><span class="cov0" title="0">{
                                                        // Ignore "already exists" errors
                                                        if !strings.Contains(strings.ToLower(err.Error()), "already exists") </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("failed to create sequence %s: %w", sequenceName, err)
                                                        }</span>
                                                }
                                        }
                                }
                        }

                        // Now create the table using the parent method
                        <span class="cov8" title="1">return m.Migrator.CreateTable(value)</span>
                }); err != nil <span class="cov0" title="0">{
                        return fmt.Errorf("failed to create table: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
